<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>reveal.js - The HTML Presentation Framework</title>

	<meta name="description" content="Coding Beer Session Java 8">
	<meta name="author" content="Roman Badura">

	<meta name="apple-mobile-web-app-capable" content="yes"/>
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

	<meta name="viewport"
		  content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css" id="theme">

	<!-- Code syntax highlighting -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>

	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
</head>

<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
<section>
	<h1>Java 8 in Action</h1>
	<img width="300" height="200" data-src="assets/java8.png" alt="Up arrow" style="background: transparent;">

	<h3>Coding Beer Session</h3>

	<p>
		<small>Created by <a href="#">Roman Badura</a></small>
	</p>
</section>

<section>
	<h2>Content</h2>

	<p>
	<ul>
		<li>Functions in Java</li>
		<li>Streams</li>
		<li>Default Methods</li>
	</ul>
	</p>
</section>

<!-- Example of nested vertical slides -->
<section>
	<section>
		<h2>Functional Interfaces & Lambdas </h2>

		<p>New view on Java methods.</p>

		<p>Functional interface (What is it?)</p>

		<p>Lambdas</p>

		<p>Method references</p>
		<br>
		<a href="#" class="navigate-down">

		</a>
	</section>
	<section>
		<h2>New view on Java methods</h2>
		<br/>

		<p>Old View</p>

		<p>New View</p>
	</section>
	<section>
		<h2>Functional interfaces</h2>

		<p>Only one abstract method.</p>

		<p>Annotation is not required. (Similar like an override)</p>

		<p>Interface can contain also default methods.</p>

		<p>They can be instantiated using lambdas</p>

		<p>Functional descriptor</p>
		<!--Signature of the abstract method of the functional interface essentially describes the signature of the lambda expression -->
		<pre><code data-trim contenteditable>
			() -> System.out.println("Run method");
		</code></pre>
		<br>

	</section>
	<section>
		<h2>Functional interfaces</h2>
		<pre><code data-trim contenteditable>
			public Funciton&lt;T, R> { R apply(T t); }
			public Predicate&lt;T> { boolean test(T t); }
			public Consumer&lt;T> { void accept(T t); }
			public Supplier&lt;T> { T get(); }
			public BiFunction&lt;T, U, R> { R apply(T t, U u); }
		</code></pre>
		<p>In package: java.util.function (42-43)</p>
		<a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank">http://docs.oracle.com/...</a>.
	</section>
	<section>
		<h2>Lambdas</h2>
		<img width="450" height="160" data-src="assets/lambda_body.png" alt="Up arrow">
		<br/>
		<ul>
			<li>Anonymous</li>
			<!-- it doesn't have explicit name like a method-->
			<li>Function</li>
			<!-- lambda isn't associated with a particular class like a method -->
			<li>Passed Around</li>
			<!-- can be passed as argument to a method or stored in variable -->
			<li>Concise</li>
			<!-- not so much boilerplate code like for anonymous classes -->
		</ul>
	</section>
	<section>
		<h2>Method references</h2>

		<p>Reuse existing method definitions</p>
		<!--and pass them just like a lambdas , when lambda does notthing but call existing method-->
		<p>More readable</p>
		<br/>
		<br/>
		<!-- it is actually not calling the method (it is a shorthand for lambda expression) -->
		<table style="font-size: 22px;">
			<thead>
			<tr>
				<th>Lambda</th>
				<th>Method reference equivalent</th>
			</tr>
			</thead>
			<tbody style="font-size: 18px">
			<tr>
				<td>(Apple a) -> a.getWeight()</td>
				<td>Apple::getWeight</td>
			<tr>
			<tr>
				<td>(str, i) -> str.substring(i)</td>
				<td>String::substring</td>
			<tr>
			<tr>
				<td>(String s) -> System.out.println(s)</td>
				<td>System.out::println</td>
			<tr>
			</tbody>
		</table>
	</section>
	<section>
		<h2>How to construct method references</h2>

		<p>A method reference to a static method</p>
		<pre><code data-trim contenteditable>
			Integer::parseInt
		</code></pre>
		<p>A method reference to an instance of an arbitrary type</p>
		<pre><code data-trim contenteditable>
			String::length
		</code></pre>
		<p>A method reference to an instance method of an existing object</p>
		<pre><code data-trim contenteditable>
			Transaction expensiveTransaction = Transaction::new;
			expensiveTransaction::getValue
		</code></pre>
		<p>Reference to constructor</p>
		<pre><code data-trim contenteditable>
			ClassName::new
		</code></pre>
		<br>

	</section>
</section>
<section>
	<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
		<h2>Streams</h2>

		<p>
			Fancy iterators over a collection of data
			<!-- update of java Api that lets you manipulate collections of data in a declarative way ( you express query rather than code an ad hoc implementation for it -->
		</p>

		<p>Sequence of elements from a source that supports data processing operations</p>

		<h3>Two important characteristics</h3>

		<p>Pipelining</p>
		<!-- many stream operations return themselves => operations can be chained (operations can be view like a database-like query) -->
		<p>Internal iteration</p><!-- iteration is behind the scene , Sofia example-->
		<p>Declarative</p> <!-- More concise and readable -->
		<p>Composable</p> <!-- Greater flexibility -->
		<p>Parallelizable</p> <!-- Better perfomance -->
		<!-- Stream can be consumed only once -->
		<p>java.util.stream.Stream</p>

		<p>Old approach Java 7</p>

		<p>New approach Java 8</p>
		<a href="#" class="navigate-down">

		</a>
	</section>
	<section data-transition="slide" data-background="#4d7e65">
		<h2>Comparision Streams Vs Collections</h2>

		<p>Collections are about data</p> <!-- collection are eagerly constructed -->
		<p>Collection is an in-memory</p>
		<!--you can add values, remove ... ; elements are computing before becoming part of the collection -->
		<p>Streams are about computation</p>

		<p>Streams is a fixed data structure whose elements are computed on demand</p>
		<!--  you can't add or remove data from it , stream is like a lazy constructed collection-->
	</section>
	<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
		<h2>Java 7 approach</h2>
		<!-- return names of dishes that are low in calories, sorted by number of calories -->
		<!-- 1 filter the elements 2. sort 3. process sorted list to select names of dishes -->
		<pre><code data-trim contenteditable>
			List&lt;Dish> lowCaloricDishes = new ArrayList<>();
			for(Dish d: menu){
			if(d.getCalories() < 400){
			lowCaloricDishes.add(d);
			}
			}
			Collections.sort(lowCaloricDishes, new Comparator&lt;Dish>() {
			public int compare(Dish d1, Dish d2){
			return Integer.compare(d1.getCalories(), d2.getCalories());
			}
			});
			List&lt;String> lowCaloricDishesName = new ArrayList<>();
			for(Dish d: lowCaloricDishes){
			lowCaloricDishesName.add(d.getName());
			}
		</code></pre>
	</section>
	<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
		<h2>Java 8 approach</h2>
		<pre><code data-trim contenteditable>
			List&lt;String> lowCaloricDishesName =
			menu.stream()
			.filter(d -> d.getCalories() < 400)
			.sorted(comparing(Dish::getCalories))
			.map(Dish::getName)
			.collect(toList());
		</code></pre>
		<pre><code data-trim contenteditable>
			List&lt;String> lowCaloricDishesName =
			menu.parallelStream()
			.filter(d -> d.getCalories() < 400)
			.sorted(comparing(Dish::getCalories))
			.map(Dish::getName)
			.collect(toList());
		</code></pre>
	</section>
	<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
		<h2>Stream pipeline</h2>

		<p>Intermediate operations</p>
		<!-- can be pipelined , they don't performe any operations until a terminal operation is invoked (they are lazy) -->
		<p>Terminal operations
		<ul>
			<li>Result is any non-stream value (List, Integer, void ...)</li>
		</ul>
		</p>
		<img width="550" height="160" data-src="assets/stream_pipeline.png" alt="Up arrow">

	</section>
	<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
		<h2>Filter</h2>
		<pre><code data-trim contenteditable>
			Stream&lt;T> filter(Predicate<? super T> predicate);
		</code></pre>
		<p>filter(d -> d->getCalories() > 300).skip(2)</p>

		<p>filter(d -> d->getCalories() > 300).distinct()</p> <!-- it depends on equals implementation of elements -->
		<p>filter(d -> d->getCalories() > 300).limit(3)</p>
		<!-- also works for unordered lists (for sets we don't know exactly which elements will be returned -->
	</section>
	<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
		<h2>Mapping</h2>

		<p>Select information from certain objects</p> <!-- in sql you can select particular column from a table -->
		<p>Can be chained</p>
		<pre><code data-trim contenteditable>
			&lt;R> Stream&lt;R> map(Function&lt;? super T, ? extends R> mapper);
		</code></pre>
		<p>Flat map</p>
		<!-- lets you replace each value of a stream with another stream and then concatenates all the generated streams into a single stream -->
		<pre><code data-trim contenteditable>
			&lt;R> Stream&lt;R> flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R>> mapper);
		</code> </pre>
	</section>
	<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
		<h2>Finding and Matching</h2>

		<p>Another data processing idiom is finding whether some elements in a set of data match a given property</p>

		<p>All operations are short circuiting (also limit)</p>
		<ul>
			<li>allMatch</li>
			<!-- check to see if all the elements of the stream match the given predicate (Short circuiting)-->
			<li>anyMatch</li>
			<!-- Return boolean and it is terminal operations. Is there an element in the stream matching the given predicate? (Short circuiting) -->
			<li>noneMatch</li>
			<!-- oposite to allMatch (Short circuiting) -->
			<li>findFirst</li>
			<!-- By parallelism -->
			<li>findAny</li>
			<!-- By parallelism -->

		</ul>
	</section>
	<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
		<h2>Reducing</h2> <!-- in functional programming "fold" -->
		<pre><code data-trim>
			<!-- first parameter is initial value; second A lambda to combine two stream elements and produce a new value -->
			T reduce(T identity, BinaryOperator&lt;T> accumulator);
		</code>	</pre>
		<!-- reduce operation can be performed by parallel -->
	</section>
	<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
		<h2>Stream operations: stateless Vs. stateful</h2>
		<!-- Operations like map and filter take each element from the input stream and produce zero or one result in the output stream.
			These operations are thus in general stateless: they don’t have an internal state -->
		<!-- But operations like reduce, sum, and max need to have internal state to accumulate the result. In this case the internal state is small.
			In our example it consisted of an int or double. The internal state is of bounded size no matter how many elements are in the stream being processed. -->
		<!-- By contrast, some operations such as sorted or distinct.
			 Both sorting and removing duplicates from a stream require knowing the previous history to do their job
			 he storage requirement of the operation is unbounded. We call this operations stateful-->
	</section>
	<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
		<h2>Primitive stream specializations</h2>

		<p>Avoid hidden boxing costs</p>

		<p>When stream is empty return 0.</p>

		<p>map, sum</p>

		<p>IntStream | mapToInt | max, min, average</p>

		<p>DoubleStream | mapToDouble</p>

		<p>LongStream | mapToLong</p>
	</section>

	<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
		<h2>Numeric ranges</h2>

		<p>range (exclusive), rangeClosed (inclusive)</p>
		<pre><code data-trim contenteditable>
			IntStream evenNumbers = IntStream.rangeClosed(1,100).filter(n -> n%2 == 0);
			System.out.println(evenNumbers.count());
		</code></pre>
	</section>
	<!-- you can also create stream with explicit values by using the static method Stream.of or create empty stream by using Stream.empty() -->
	<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
		<h2>Creation of streams</h2>

		<p>From explicit values - static method Stream.of</p>

		<p>Emtpy stream - Stream.empty</p>

		<p>From array - Arrays.stream(arr)</p>

		<p>Streams from files - Files.lines(Paths.get("newSong.txt"))</p>

		<p>Streams from functions - Stream.iterate and Stream.generate</p>
		<!-- with those two we can create infinite stream, because values are produced on demand and can be computed forever - Stream.iterate(0, n -> n + 2) -->
	</section>

</section>
<section>
	<section data-background="#b5533c">
		<h2>Collecting data with streams : Collectors</h2>

		<p>Parameters to Stream method collect</p> <!-- collect is a terminal operation that takes as argument various recipes (called collectors)
														for accumulating the elements of a stream into a summary result. -->
		<p>Main functionalities</p>
		<ul>
			<li>Reducing and summarizing stream elements to a single value</li>
			<li>Grouping elements</li>
			<li>Partitioning elements</li>
		</ul>
	</section>
	<section data-transition="slide" data-background="#b5533c">
		<h2>Reducing and summarizing</h2>

		<p>Finding max and min</p>
		<ul>
			<li>Collectors.counting()</li>
			<li>Collectors.maxBy</li>
			<li>Collectors.minBy</li>
		</ul>
		<p>Summarization</p>
		<ul>
			<li>Collectors.summing [Int, Double, Long]</li>
			<li>Collectors.averaging [Int, Double, Long]</li>
			<li>Collectors.summarizingIng [Int, Double, Long]</li>
			<!-- return all statistics average, min, max, count; return type is [Int, Double, Long] SummaryStatistics -->
		</ul>
		<p>Joining Strings</p>
		<ul>
			<li>Collectors.joining()</li>
		</ul>
		<!-- All operations above can be replaced with reduce method but there is a problem with readability -->
	</section>
	<section data-transition="slide" data-background="#b5533c">
		<h2>Grouping</h2>

		<p>Grouping can be multilevel</p> <!-- result is always Map<Ele1, List<Obj1>> -->
		<p>After grouping we can use every collector</p>

		<p>Partitioning</p>
	</section>
	<section data-transition="slide" data-background="#b5533c">
		<h2>Collector interface</h2>
		<pre><code data-trim contenteditable>
			public interface Collector&lt;T, A, R> {
			Supplier&lt;A> supplier();
			BiConsumer&lt;A, T> accumulator(); <!-- perform reduction process -->
			Function&lt;A, R> finisher();     <!-- the last executed method and this method call method identify() -->
			BinaryOperator&lt;A> combiner();
			<!-- combine divided results into one part this is done for parallel processing if we don't use parallel stream this method could be empty-->
			Set&lt;Characteristics> characteristics();
			<!-- Provide hints about whether the stream can be reduced in parallel and which optimizations are valid Contain three items. It is enum with 3 valus
				 1) UNORDERED - the result of the reduction isn't affected by the order in which are items processed
				2) CONCURRENT - the accumulator function can be called concurrently from multiple threads;
								 the stream will be processed in parallel only if its underlying data source is unordered.
				3) IDENTITY_FINISH - this also implies that it is safe to do an unchecked cast from the accumulator A to the result B -->
			}
		</code></pre>
		<ul>
			<li>T</li>
			<!-- is a generic type of the items in the stream to be collected -->
			<li>A</li>
			<!-- is a type of accumulator, the object on which the partial result will be accumulated during the collection process -->
			<li>R</li>
			<!-- is a type of object resulting from the collect operation -->
		</ul>
		<p>You can create own collector but you can also utilize option of Stream that has overloaded collect method</p>
		<!-- thi overloaded method accept three functions supplier, accumulator, combiner -->
	</section>
</section>
<section>
	<section>
		<h2>Parallel Streams</h2>

		<p>Stream is internally divided multiple chunks</p>

		<p>You can decide which part can be performed parallel or seqeuntial</p>
		<pre><code data-trim>
			stream.parallel()
			.filter(...)
			.sequential()
			.map(...)
			.parallel()
			.reduce();
		</code></pre>
		<p>Internally use the default ForkJoinPool</p>
		<!-- how many threads process data is fetched from - Runtime.getRuntime().availableProcessor() -->
	</section>
	<section data-transition="slide" data-background="#b5533c">
		<p>Using parallel streams correctly</p>
		<ul>
			<li>Don't use in algorithm that mutate some shared state
				<!-- race condition -->
				<pre><code data-trim>
					public static long sideEffectSum(long n) {
					Accumulator accumulator = new Accumulator();
					LongStream.rangeClosed(1, n).forEach(accumulator::add);
					return accumulator.total;
					}
					public class Accumulator {
					public long total = 0;
					public void add(long value) { total += value; }
					}
					measurePerf(ParallelStreams::sideEffectParallelSum, 10_000_000L);
				</code></pre>
			</li>
		</ul>
		<p>Using parallel stream effectively</p>
		<ul>
			<li>None quantitative meassure</li>
			<li>Don't use operation with automatic boxing, unboxing</li>
			<!-- IntStream, LongStream, DoubleStream -->
			<li>Operations such as: limit, findFirst are to expensive</li>
			<!-- because rely on the order of the elements -->
			<li>You can always turn the ordered stream into an unordered</li>
			<!-- Invoking method unordered -->
			<table style="font-size: 22px;">
				<thead>
				<tr>
					<th>Source</th>
					<th>Decomposability</th>
				</tr>
				</thead>
				<tbody style="font-size: 18px">
				<tr>
					<td>ArrayList</td>
					<td>Excellent</td>
				<tr>
				<tr>
					<td>LinkedList</td>
					<td>Poor</td>
				<tr>
				<tr>
					<td>IntStream.range</td>
					<td>Excellent</td>
				<tr>
				<tr>
					<td>Stream.iterate</td>
					<td>Poor</td>
				<tr>
				<tr>
					<td>HashSet</td>
					<td>Good</td>
				<tr>
				<tr>
					<td>TreeSet</td>
					<td>Good</td>
				<tr>
				</tbody>
			</table>
		</ul>
	</section>
	<section>
		<h2>Fork/join Framework</h2>

		<p>Recursively split a parallelizable task into smaller tasks and then combine the results</p>
		<!-- implementation of ExecutorService interface , which distributes those subtasks to worker thread in a thread pool, call ForkJoinPool
		 To submit tasks to this pool, you have to create a subclass of RecursiveTask<R>, where R is the type of the result produced by the parallelized
		 task (and each of its subtasks) or of RecursiveAction if the task returns no result (it could be updating other nonlocal structures, though).
		 To define RecursiveTasks you need only implement its single abstract method, compute:
		 if (task is small enough or no longer divisible) {
			compute task sequentially
		} else {
			split task in two subtasks
			call this method recursively possibly further splitting each subtask
			wait for the completion of all subtasks
			combine the results of each subtask
		}
		-->
		<p>Work stealing</p>
		<!-- Tasks are more or less evenly divided on all the threads in the ForkJoinPool. Each of these threads hold queue of tasks. If one queue is empty earlier
			instead of becoming idle randomly queue of different thread and steal a task-->
	</section>
	<section>
		<h2>Spliterator</h2>

		<p>An object for traversing and partitioning elements of a source</p>
		<pre><code data-trim>
			public interface Spliterator&lt;T> {
			boolean tryAdvance(Consumer&lt;? super T> action);
			<!-- like a normal Iterator return true if there are still other elements to be traversed -->
			Spliterator&lt;T> trySplit();
			<!-- split elements to the second Spliterator - those two can be processed in parallel -->
			long estimateSize();
			<!-- estimate of number elements remaining to traverse -->
			int characteristics();
			<!-- Unfortunately, although these conceptually overlap with characteristics of a collector, they’re coded differently.) -->
			}
			<!-- T is type of elements traversed by the Spliterator -->
		</code></pre>
	</section>
</section>
<section>
	<section>
		<h2>Effective Java 8 Programming</h2>

		<p>Refactoring</p>
		<ul>
			<li>Refactoring anonymous classes to lambda expressions</li>
			<li>Refactoring lambda expressions to method references</li>
			<li>Refactoring imperative-style data processing to streams</li>
		</ul>
		<p>To log intermediate values in lambda use peek method</p>
	</section>
	<section data-transition="slide" data-background="#b5533c">
		<h2>Design Patterns</h2>
		<ul>
			<li>Strategy</li>
			<li>Template Method</li>
			<li>Observer</li>
			<li>Chain of responsibility</li>
			<li>Factory</li>
		</ul>
	</section>
</section>
<section>
	<section>
		<h2>Interface changes</h2>
		<ul>
			<li>Static methods are allows in interface</li>
			<!-- Collection and Collections, now Collections class is not needed because we can move all methods from this class to interface -->
			<li>Default methods - allows you to provide default implementation for methods in an interface</li>

		</ul>
		<pre><code data-trim>
			default void sort(Comparator<? super E> c){
			Collections.sort(this, c);
			}
		</code></pre>
		<p>sort method int list, stream method in collection</p>

		<p>Abstract class Vs. Interface</p>
		<!-- 1) Class can extend only from one abstract class, but class can implement multiple interfaces
			 2) Abstract class can enforce common state through instance variables -->
		<p>Class can inherit more than one methods with the same signature</p>
		<!-- two interfaces have methods with the same signature, which method should be used?
		 	1) Classes always win. (method declaration in the class or a superclass takes priority)
		 	2) Sub-interface win. (method in most-specific interface win)
		 	3) It it is still not clear, Class has to explicitly select (overriding method and calling method from proper interface )
		-->
		<p>New syntax: X.super.method()</p>
		<!-- X is super interface -->
		<p>For interface is not possible to implement methods from Object</p>
		<!-- toString(); equals;.... because this method are about state and interface has no state-->
	</section>
	<section data-transition="slide" data-background="#b5533c">
		<h2>Design Patterns</h2>
		<ul>
			<li>Strategy</li>
			<li>Template Method</li>
			<li>Observer</li>
			<li>Chain of responsibility</li>
			<li>Factory</li>
		</ul>
	</section>
</section>
<section>
	<section>
		<h2>Null references</h2>

		<p>Introduced by Tony Hoare in 1965</p><!-- Because it was so simple to implement -->
		<p>"my billion-dollar mistake"</p>
		<!-- Java always hides pointers from developers except in one case: the null pointer -->
		<p>How to solve null pointer other languages</p>

		<p>Groovy (def variable = person?.car?.insurance?.name</p> <!-- miracle letter ? :) -->
		<p>Haskel (Maybe type)</p>

		<p>Scala (Option[T])</p>

		<h2>Optional</h2>
		<!-- model if some object can be or can not be null class Car{} class Person{ private Optional<Car> car;} person can has or can not has a car -->
		<!-- You can think of Optional like a stream with at most a single element -->
		<p>java.util.Optional</p>

		<p>Is a container class to represent the existence or absence of a value</p>

		<p>Purpose of optional is to help design more comprehensible API</p>
		<ul>
			<li>isPresent</li>
			<!-- returns true if Optional contains a value, false otherwise -->
			<li>ifPresent(Consumer&lt;T> block)</li>
			<!-- Executes the given block if a value is present -->
			<li>T get()</li>
			<!-- return the value if present; otherwise it throws a NoSuchElementException, it is not good idea to use this method -->
			<li>T orElse(T other)</li>
			<!--return the value if present, otherwise it returns default value -->
			<li>&lt;U> Optional&lt;U> map(Function&lt;? super T, ? extends U> mapper))</li>
			<!-- if value is present return value if value is not present return empty -->
			<li>&lt;U> Optional&lt;U> flatMap(Function&lt;? super T, Optional&lt;U>> mapper)</li>
			<!-- Optional<Optional<Car>> statement flatten to Optional<Car> statement -->
			<li>Optional&lt;T> filter(Predicate&lt;? super T> predicate)</li>
		</ul>
		<pre><code>
			person.getCar().getInsurance().getName()
		</code></pre>
		<pre><code>
			person.flatMap(Person::getCar).flatMap(Car::getInsurance)
			.map(Insurance::getName).orElse("Unknown");
		</code></pre>
		<p>Filter</p>
		<pre><code>
			Insurance insurance = ...;
			if(insurance != null && "CambridgeInsurance".equals(insurance.getName())){
			System.out.println("ok");
			}
		</code></pre>
		<pre><code>
			Optional&lt;Insurance> optInsurance = ...;
			optInsurance.filter(insurance -> "CambridgeInsurance".equals(insurance.getName()))
			.ifPresent(x -> System.out.println("ok"));
		</code></pre>
		<p>Doesn't implement Serializable</p>

		<p>Primitive specialized version</p>

		<p>OptionalInt, OptionalDouble, OptionalLong</p>
		<!-- The sum example was convenient because it has a default value: 0. But if you want to calculate the maximum element in an IntStream, you need something different because 0 is a wrong result -->
	</section>
	<section data-transition="slide" data-background="#b5533c">
		<h2>Creating Optional objects</h2>
		<ul>
			<li>Empty optional
				<pre><code data-trim>
					Optional&lt;Car> optCar = Optional.empty();
				</code></pre>
			</li>
			<li>Optional from a non-null value
				<pre><code data-trim>
					Optional&lt;Car> optCar = Optional.of(car); <!-- if car were null => NPE -->
				</code></pre>
			</li>
			<li>Optional from null
				<pre><code data-trim>
					Optional&lt;Car> optCar = Optional.ofNullable(car);
					<!-- if car were null => the Optional object would be empty -->
				</code></pre>
			</li>
		</ul>
	</section>
</section>

<section>
	<section>
		<h2>Optional</h2>

		<p>java.util.Optional</p>

		<p>Is a container class to represent the existence or absence of a value</p>
		<ul>
			<li>isPresent</li>
			<!-- returns true if Optional contains a value, false otherwise -->
			<li>ifPresent(Consumer&lt;T> block)</li>
			<!-- Executes the given block if a value is present -->
			<li>T get()</li>
			<!-- return the value if present; otherwise it throws a NoSuchElementException -->
			<li>T orElse(T other)</li>
			<!--return the value if present, otherwise it returns default value -->
		</ul>
		<p>Primitive specialized version</p>

		<p>OptionalInt, OptionalDouble, OptionalLong</p>
		<!-- The sum example was convenient because it has a default value: 0. But if you want to calculate the maximum element in an IntStream, you need something different because 0 is a wrong result -->
		<p>Optional&lt;Object> value = Optional.ofNullable(map.get("key"));</p>
		<!--  Use this method every time you want to safely transform a value that could be potentially null into na optional -->
		<pre><code>
			public static Optional&lt;Integer> stringToInt(String s) {
			try {
			return Optional.of(Integer.parseInt(s));
			} catch (NumberFormatException e) {
			return Optional.empty();
			}
			}
		</code></pre>
	</section>

</section>
<section>
	<h2>Future</h2> <!-- represent result of asynchronous computation -->
	<!-- Concurrently executed code You can think of it as taking a bag of clothes to your favorite dry cleaner. They will give
		you a receipt to tell you when your clothes are cleaned (a Future). In the meantime,
		you can do some other activities
	-->
	<p>CompletableFuture</p> <!-- CompletableFuture is to Future the same as Stream to Collection -->
</section>

<section>
	<h2>Date and Time API</h2>

	<p>LocalDate </p>
	<!-- immutable date without time part, it doesn't carry any information about time zone
		 You can also obtain the current date from system clock LocalDate.now-->
	<p>TemporalField</p><!-- interface defining how to access the value of a specific field of a temporal object -->
	<p>ChronoField</p><!-- enumaration which implements TemporalField interface, with chronoField we can obtain
						via get all values date.get(ChronoField.Year); -->
	<p>LocalTime</p><!-- represents time of day. you can create it using of methods -->
	<!-- both localDate and localTime can be created from string -->
	<p>LocalDateTime</p> <!-- composite class of LocalDate and LocalTime, withou time zone  -->
	<p>Instant</p> <!-- number of seconds pass from 1970 january 1 januar -->
	<p>Duration</p> <!-- not allow to mix LocalDateTime with Instant -->
	<p>Period</p>

	<p>TemporalAdjusters</p>
	<!-- allow you to manipulate a date in a more complex way than just changing one of its values, custom date transformations -->
	<p>DateTimeFormatter</p>

	<p>DateTimeFormatterBuilder</p><!-- case insensitive parsing, lanient parsing (not precisely match) -->
	<section>
		<h2>Different Time Zones and Calendars</h2>

		<p>java.time.ZoneId</p>
		<img width="300" height="150" data-src="assets/date_time.png"/>
		<!-- replacement for old java.util.TimeZone
			 specific ZoneId is identified by a region Id
			 Convert old TimeZone to ZoneId => ZoneId zoneId = TimeZone.getDefault().toZoneId();
			 Zone works with LocalDate, LocalTime via ZoneLocalDate, ZoneLocalTime
			 ZonedDateTime zonedDateTime = date1.atStartOfDay(zone);
			-->
		<p>ZoneOffset</p>

		<p>ThaiBuddhistDate, MinguoDate, JapaneseDate, and Hijrah-Date</p>
	</section>
</section>

<section data-markdown>
	<script type="text/template">
		## Markdown support

		Write content using inline or external Markdown.
		Instructions and more info available in the [readme](https://github.com/hakimel/reveal.js#markdown).

		```
		<section data-markdown>
			## Markdown support

			Write content using inline or external Markdown.
			Instructions and more info available in the [readme](https://github.com/hakimel/reveal.js#markdown).
		</section>
		```
	</script>
</section>

<section>
	<section id="fragments">
		<h2>Fragments</h2>

		<p>Hit the next arrow...</p>

		<p class="fragment">... to step through ...</p>

		<p><span class="fragment">... a</span> <span class="fragment">fragmented</span> <span
				class="fragment">slide.</span></p>

		<aside class="notes">
			This slide has fragments which are also stepped through in the notes window.
		</aside>
	</section>
	<section>
		<h2>Fragment Styles</h2>

		<p>There's different types of fragments, like:</p>

		<p class="fragment grow">grow</p>

		<p class="fragment shrink">shrink</p>

		<p class="fragment roll-in">roll-in</p>

		<p class="fragment fade-out">fade-out</p>

		<p class="fragment current-visible">current-visible</p>

		<p class="fragment highlight-red">highlight-red</p>

		<p class="fragment highlight-blue">highlight-blue</p>
	</section>
</section>

<section id="transitions">
	<h2>Transition Styles</h2>

	<p>
		You can select from different transitions, like: <br>
		<a href="?transition=none#/transitions">None</a> -
		<a href="?transition=fade#/transitions">Fade</a> -
		<a href="?transition=slide#/transitions">Slide</a> -
		<a href="?transition=convex#/transitions">Convex</a> -
		<a href="?transition=concave#/transitions">Concave</a> -
		<a href="?transition=zoom#/transitions">Zoom</a>
	</p>
</section>

<section id="themes">
	<h2>Themes</h2>

	<p>
		reveal.js comes with a few themes built in: <br>
		<!-- Hacks to swap themes after the page has loaded. Not flexible and only intended for the reveal.js demo deck. -->
		<a href="#"
		   onclick="document.getElementById('theme').setAttribute('href','css/theme/black.css'); return false;">Black
			(default)</a> -
		<a href="#"
		   onclick="document.getElementById('theme').setAttribute('href','css/theme/white.css'); return false;">White</a>
		-
		<a href="#"
		   onclick="document.getElementById('theme').setAttribute('href','css/theme/league.css'); return false;">League</a>
		-
		<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/sky.css'); return false;">Sky</a>
		-
		<a href="#"
		   onclick="document.getElementById('theme').setAttribute('href','css/theme/beige.css'); return false;">Beige</a>
		-
		<a href="#"
		   onclick="document.getElementById('theme').setAttribute('href','css/theme/simple.css'); return false;">Simple</a>
		<br>
		<a href="#"
		   onclick="document.getElementById('theme').setAttribute('href','css/theme/serif.css'); return false;">Serif</a>
		-
		<a href="#"
		   onclick="document.getElementById('theme').setAttribute('href','css/theme/night.css'); return false;">Night</a>
		-
		<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/moon.css'); return false;">Moon</a>
		-
		<a href="#"
		   onclick="document.getElementById('theme').setAttribute('href','css/theme/solarized.css'); return false;">Solarized</a>
	</p>
</section>

<section>
	<section data-background="#dddddd">
		<h2>Slide Backgrounds</h2>

		<p>
			Set <code>data-background="#dddddd"</code> on a slide to change the background color. All CSS color formats
			are supported.
		</p>
		<a href="#" class="navigate-down">
			<img width="178" height="238" data-src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png"
				 alt="Down arrow">
		</a>
	</section>
	<section data-background="https://s3.amazonaws.com/hakim-static/reveal-js/image-placeholder.png">
		<h2>Image Backgrounds</h2>
		<pre><code>&lt;section data-background="image.png"&gt;</code></pre>
	</section>
	<section data-background="https://s3.amazonaws.com/hakim-static/reveal-js/image-placeholder.png"
			 data-background-repeat="repeat" data-background-size="100px">
		<h2>Tiled Backgrounds</h2>
		<pre><code style="word-wrap: break-word;">&lt;section data-background="image.png"
			data-background-repeat="repeat" data-background-size="100px"&gt;</code></pre>
	</section>
	<section
			data-background-video="https://s3.amazonaws.com/static.slid.es/site/homepage/v1/homepage-video-editor.mp4,https://s3.amazonaws.com/static.slid.es/site/homepage/v1/homepage-video-editor.webm"
			data-background-color="#000000">
		<div style="background-color: rgba(0, 0, 0, 0.9); color: #fff; padding: 20px;">
			<h2>Video Backgrounds</h2>
			<pre><code style="word-wrap: break-word;">&lt;section
				data-background-video="video.mp4,video.webm"&gt;</code></pre>
		</div>
	</section>
</section>

<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
	<h2>Background Transitions</h2>

	<p>
		Different background transitions are available via the backgroundTransition option. This one's called "zoom".
	</p>
	<pre><code>Reveal.configure({ backgroundTransition: 'zoom' })</code></pre>
</section>


<section>
	<h2>Pretty Code</h2>
					<pre><code data-trim contenteditable>
						function linkify( selector ) {
						if( supports3DTransforms ) {

						var nodes = document.querySelectorAll( selector );

						for( var i = 0, len = nodes.length; i &lt; len; i++ ) {
						var node = nodes[i];

						if( !node.className ) {
						node.className += ' roll';
						}
						}
						}
						}
					</code></pre>
	<p>Code syntax highlighting courtesy of <a href="http://softwaremaniacs.org/soft/highlight/en/description/">highlight.js</a>.
	</p>
</section>


<section>
	<h2>Clever Quotes</h2>

	<p>
		These guys come in two forms, inline: <q
			cite="http://searchservervirtualization.techtarget.com/definition/Our-Favorite-Technology-Quotations">
		&ldquo;The nice thing about standards is that there are so many to choose from&rdquo;</q> and block:
	</p>
	<blockquote cite="http://searchservervirtualization.techtarget.com/definition/Our-Favorite-Technology-Quotations">
		&ldquo;For years there has been a theory that millions of monkeys typing at random on millions of typewriters
		would
		reproduce the entire works of Shakespeare. The Internet has proven this theory to be untrue.&rdquo;
	</blockquote>
</section>

<section>
	<h2>Intergalactic Interconnections</h2>

	<p>
		You can link between slides internally,
		<a href="#/2/3">like this</a>.
	</p>
</section>

<section>
	<h2>Speaker View</h2>

	<p>There's a <a href="https://github.com/hakimel/reveal.js#speaker-notes">speaker view</a>. It includes a timer,
		preview of the upcoming slide as well as your speaker notes.</p>

	<p>Press the <em>S</em> key to try it out.</p>

	<aside class="notes">
		Oh hey, these are some notes. They'll be hidden in your presentation, but you can see them if you open the
		speaker notes window (hit 's' on your keyboard).
	</aside>
</section>

<section>
	<h2>Export to PDF</h2>

	<p>Presentations can be <a href="https://github.com/hakimel/reveal.js#pdf-export">exported to PDF</a>, here's an
		example:</p>
	<iframe src="//www.slideshare.net/slideshow/embed_code/42840540" width="445" height="355" frameborder="0"
			marginwidth="0" marginheight="0" scrolling="no"
			style="border:3px solid #666; margin-bottom:5px; max-width: 100%;" allowfullscreen></iframe>
</section>

<section>
	<h2>Global State</h2>

	<p>
		Set <code>data-state="something"</code> on a slide and <code>"something"</code>
		will be added as a class to the document element when the slide is open. This lets you
		apply broader style changes, like switching the page background.
	</p>
</section>

<section data-state="customevent">
	<h2>State Events</h2>

	<p>
		Additionally custom events can be triggered on a per slide basis by binding to the <code>data-state</code> name.
	</p>
					<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
						Reveal.addEventListener( 'customevent', function() {
						console.log( '"customevent" has fired' );
						} );
					</code></pre>
</section>

<section>
	<h2>Take a Moment</h2>

	<p>
		Press B or . on your keyboard to pause the presentation. This is helpful when you're on stage and want to take
		distracting slides off the screen.
	</p>
</section>

<section>
	<h2>Much more</h2>
	<ul>
		<li>Right-to-left support</li>
		<li><a href="https://github.com/hakimel/reveal.js#api">Extensive JavaScript API</a></li>
		<li><a href="https://github.com/hakimel/reveal.js#auto-sliding">Auto-progression</a></li>
		<li><a href="https://github.com/hakimel/reveal.js#parallax-background">Parallax backgrounds</a></li>
		<li><a href="https://github.com/hakimel/reveal.js#keyboard-bindings">Custom keyboard bindings</a></li>
	</ul>
</section>

<section style="text-align: left;">
	<h1>THE END</h1>

	<p>
		- <a href="http://slides.com">Try the online editor</a> <br>
		- <a href="https://github.com/hakimel/reveal.js">Source code &amp; documentation</a>
	</p>
</section>

</div>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

	// Full list of configuration options available at:
	// https://github.com/hakimel/reveal.js#configuration
	Reveal.initialize({
		controls: true,
		progress: true,
		history: true,
		center: true,

		transition: 'slide', // none/fade/slide/convex/concave/zoom

		// Optional reveal.js plugins
		dependencies: [
			{ src: 'lib/js/classList.js', condition: function () {
				return !document.body.classList;
			} },
			{ src: 'plugin/markdown/marked.js', condition: function () {
				return !!document.querySelector('[data-markdown]');
			} },
			{ src: 'plugin/markdown/markdown.js', condition: function () {
				return !!document.querySelector('[data-markdown]');
			} },
			{ src: 'plugin/highlight/highlight.js', async: true, condition: function () {
				return !!document.querySelector('pre code');
			}, callback: function () {
				hljs.initHighlightingOnLoad();
			} },
			{ src: 'plugin/zoom-js/zoom.js', async: true },
			{ src: 'plugin/notes/notes.js', async: true }
		]
	});

</script>

</body>
</html>
